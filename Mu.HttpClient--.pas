unit Mu.HttpClient;

interface

{$IFDEF MSWINDOWS}
{$HPPEMIT '#pragma comment(lib, "winhttp")'}
{$HPPEMIT '#pragma comment(lib, "crypt32")'}
{$ENDIF}
{$SCOPEDENUMS ON}

uses
  windows,
  System.Sysutils, System.Classes, System.Generics.Collections,
  System.Net.URLClient, System.Net.HttpClient, System.Net.Mime,
  Mu.HttpClientHelper

    ;

type
  // ------------------------------------------------------------------------------------------------------------------ //
  // ------------------------------------------------------------------------------------------------------------------ //

  /// <summary> Request completion Event signature</summary>
  /// <param name="Sender"> HTTPClientComponent that invoked the Event</param>
  /// <param name="AResponse">Response generated by the request</param>
  TRequestCompletedEvent = procedure(const Sender: TObject;
    const AResponse: IHTTPResponse) of object;
  /// <summary> Request error Event signature</summary>
  /// <param name="Sender"> HTTPClientComponent that invoked the Event</param>
  /// <param name="AError">Error generated by the request</param>
  TRequestErrorEvent = procedure(const Sender: TObject; const AError: string)
    of object;

  // ------------------------------------------------------------------------------------------------------------------ //
  // ------------------------------------------------------------------------------------------------------------------ //

  /// <summary>Component to Manage an HTTPClient</summary>
  TMuHTTPClient = class(TComponent)
  private
    FHttpClient: THttpClient;
    FOnRequestCompleted: TRequestCompletedEvent;
    FOnRequestError: TRequestErrorEvent;
    FOnReceiveData: TReceiveDataEvent;

    FURI: TURI;

    procedure DoOnRequestCompleted(const Sender: TObject;
      const AResponse: IHTTPResponse);
    procedure DoOnRequestError(const Sender: TObject; const AError: string);
    procedure DoOnReceiveData(const Sender: TObject; AContentLength: Int64;
      AReadCount: Int64; var Abort: Boolean);

    function GetMaxRedirects: Integer;
    procedure SetMaxRedirects(const Value: Integer);
    procedure SetAuthEvent(const Value
      : TCredentialsStorage.TCredentialAuthevent);
    procedure SetOnNeedClientCertificate(const Value
      : TNeedClientCertificateEvent);
    procedure SetOnValidateServerCertificate(const Value
      : TValidateCertificateEvent);
    function GetAuthEvent: TCredentialsStorage.TCredentialAuthevent;
    function GetOnNeedClientCertificate: TNeedClientCertificateEvent;
    function GetOnValidateServerCertificate: TValidateCertificateEvent;
    function GetProxySettings: TProxySettings;
    procedure SetProxySettings(const Value: TProxySettings);
    function GetAllowCookies: Boolean;
    procedure SetAllowCookies(const Value: Boolean);
    function GetCookieManager: TCookieManager;
    procedure SetCookieManager(const Value: TCookieManager);
    function GetHandleRedirects: Boolean;
    procedure SetHandleRedirects(const Value: Boolean);
    function GetCustomHeaderValue(const AName: string): string;
    procedure SetCustomHeaderValue(const AName, Value: string);
    function GetAccept: string;
    function GetAcceptCharSet: string;
    function GetAcceptEncoding: string;
    function GetAcceptLanguage: string;
    function GetContentType: string;
    procedure SetAccept(const Value: string);
    procedure SetAcceptCharSet(const Value: string);
    procedure SetAcceptEncoding(const Value: string);
    procedure SetAcceptLanguage(const Value: string);
    procedure SetContentType(const Value: string);
    function GetCredentialsStorage: TCredentialsStorage;
    procedure SetCredentialsStorage(const Value: TCredentialsStorage);
    function GetUserAgent: string;
    procedure SetUserAgent(const Value: string);

    function getReferer(): String;
    procedure setReferer(aValue: string);
    function GetLastURL(): String;
    function GetDirectTimes(): Integer;
  public
    /// <summary> Initializes the HTTPComponent </summary>
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    // ------------------------------------------- //
    // Standard HTTP Methods
    // ------------------------------------------- //
    /// <summary>Send 'DELETE' command to url</summary>
    function Delete(const AURL: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'OPTIONS' command to url</summary>
    function Options(const AURL: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url</summary>
    function Get(const AURL: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'TRACE' command to url</summary>
    function Trace(const AURL: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'HEAD' command to url</summary>
    function Head(const AURL: string; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse;

    /// <summary>Send 'GET' command to url adding Range header</summary>
    /// <remarks>It's used for resume downloads</remarks>
    function GetRange(const AURL: string; AStart: Int64; AnEnd: Int64 = -1;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse;

    /// <summary>Post a raw file without multipart info</summary>
    function Post(const AURL: string; const ASourceFile: string;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse; overload;
    /// <summary>Post TStrings values adding multipart info</summary>
    function Post(const AURL: string; const ASource: TStrings;
      const AResponseContent: TStream = nil; const AEncoding: TEncoding = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a stream without multipart info</summary>
    function Post(const AURL: string; const ASource: TStream;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse; overload;
    /// <summary>Post a multipart form data object</summary>
    function Post(const AURL: string; const ASource: TMultipartFormData;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse; overload;

    /// <summary>Send 'PUT' command to url</summary>
    function Put(const AURL: string; const ASource: TStream = nil;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse;

    // Non standard command procedures ...
    /// <summary>Send 'MERGE' command to url</summary>
    function Merge(const AURL: string; const ASource: TStream;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send a special 'MERGE' command to url. Command based on a 'PUT' + 'x-method-override' </summary>
    function MergeAlternative(const AURL: string; const ASource: TStream;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function Patch(const AURL: string; const ASource: TStream = nil;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse; overload;
    /// <summary>Send a special 'PATCH' command to url. Command based on a 'PUT' + 'x-method-override' </summary>
    function PatchAlternative(const AURL: string; const ASource: TStream = nil;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse; overload;

    /// <summary>You have to use this function to Execute a given Request</summary>
    /// <param name="ARequest">The request that is going to be Executed</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interfaced object and
    /// It's released automatically.</returns>
    function Execute(const ARequest: IHTTPRequest;
      const AContentStream: TStream = nil): IHTTPResponse; overload;

    /// <summary>You have to use this function to Execute a Request</summary>
    /// <remarks></remarks>
    /// <param name="ARequestMethod">The request method that is going to be Executed</param>
    /// <param name="AURI">The URI that contains the information for the request that is going to be Executed</param>
    /// <param name="ASourceStream">The stream to provide the request data.</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <param name="AHeaders">Additions headers to be passed to the request that is going to be Executed</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interface and It's
    /// released automatically.</returns>
    function Execute(const ARequestMethod: string; const AURI: TURI;
      const ASourceStream: TStream = nil; const AContentStream: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;

    /// <summary>You have to use this function to Execute a given Request</summary>
    /// <remarks></remarks>
    /// <param name="ARequestMethod">The request method that is going to be Executed</param>
    /// <param name="AURIStr">The URI string that contains the information for the request that is going to be Executed</param>
    /// <param name="ASourceStream">The stream to provide the request data.</param>
    /// <param name="AContentStream">The stream to store the response data. If provided the user is responsible
    /// of releasing it. If not provided will be created internally and released when not needed.</param>
    /// <param name="AHeaders">Additions headers to be passed to the request that is going to be Executed</param>
    /// <returns>The platform dependant response object associated to the given request. It's an Interface and It's
    /// released automatically.</returns>
    function Execute(const ARequestMethod: string; const AURIStr: string;
      const ASourceStream: TStream = nil; const AContentStream: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload; inline;

    /// <summary> Cookie manager object to be used by the client.</summary>
    property CookieManager: TCookieManager read GetCookieManager
      write SetCookieManager;
    /// <summary> CustomHeaders to be used by the client.</summary>
    property CustomHeaders[const AName: string]: string
      read GetCustomHeaderValue write SetCustomHeaderValue;

    /// <summary> Credentials Storage to be used by the client</summary>
    property CredentialsStorage: TCredentialsStorage read GetCredentialsStorage
      write SetCredentialsStorage;

    /// <summary> Proxy Settings to be used by the client.</summary>
    property ProxySettings: TProxySettings read GetProxySettings
      write SetProxySettings;

    property URI: TURI read FURI write FURI;
    Property LastURL: string read GetLastURL;
    property DirectTimes: Integer read GetDirectTimes;
  published
    /// <summary> Cookies policy to be used by the client.</summary>
    /// <remarks>If false the cookies from server will not be accepted,
    /// but the cookies in the cookie manager will be sent.</remarks>
    property AllowCookies: Boolean read GetAllowCookies write SetAllowCookies;
    /// <summary> Redirection policy to be used by the client.</summary>
    property HandleRedirects: Boolean read GetHandleRedirects
      write SetHandleRedirects;
    /// <summary> Maximum number of redirects</summary>
    property MaxRedirects: Integer read GetMaxRedirects write SetMaxRedirects
      default 5;

    /// <summary>Property to manage the 'Accept' header</summary>
    property Accept: string read GetAccept write SetAccept;
    /// <summary>Property to manage the 'Accept-CharSet' header</summary>
    property AcceptCharSet: string read GetAcceptCharSet write SetAcceptCharSet;
    /// <summary>Property to manage the 'Accept-Encoding' header</summary>
    property AcceptEncoding: string read GetAcceptEncoding
      write SetAcceptEncoding;
    /// <summary>Property to manage the 'Accept-Language' header</summary>
    property AcceptLanguage: string read GetAcceptLanguage
      write SetAcceptLanguage;
    /// <summary>Property to manage the 'Content-Type' header</summary>
    property ContentType: string read GetContentType write SetContentType;
    /// <summary> Property to set the UserAgent sent with the request </summary>
    property UserAgent: string read GetUserAgent write SetUserAgent;

    property Referer: string read getReferer write setReferer;

    /// <summary> Event fired when a ClientCertificate is needed</summary>
    property OnNeedClientCertificate: TNeedClientCertificateEvent
      read GetOnNeedClientCertificate write SetOnNeedClientCertificate;
    /// <summary> Event fired when checking the validity of a Server Certificate</summary>
    property OnValidateServerCertificate: TValidateCertificateEvent
      read GetOnValidateServerCertificate write SetOnValidateServerCertificate;

    /// <summary> UserName needed to be authenticated to the proxy</summary>
    property OnAuthEvent: TCredentialsStorage.TCredentialAuthevent
      read GetAuthEvent write SetAuthEvent;

    /// <summary> Event fired when a request finishes</summary>
    property OnRequestCompleted: TRequestCompletedEvent read FOnRequestCompleted
      write FOnRequestCompleted;
    /// <summary> Event fired when a request has an error</summary>
    property OnRequestError: TRequestErrorEvent read FOnRequestError
      write FOnRequestError;

    /// <summary>Property to manage the ReceiveData Event</summary>
    property OnReceiveData: TReceiveDataEvent read FOnReceiveData
      write FOnReceiveData;
  end;

  // ------------------------------------------------------------------------------------------------------------------ //
  // ------------------------------------------------------------------------------------------------------------------ //

  /// <summary>Component to handle HTTP Requests</summary>
  TMuHTTPRequest = class(TComponent)
  private
    FClient: TMuHTTPClient;

    FContentStream: TStream;
    FSourceStream: TStream;

    FURL: string;
    FMethodString: string;

    FHttpRequest: IHTTPRequest;
    FHttpResponse: IHTTPResponse;

    FOnNeedClientCertificate: TNeedClientCertificateEvent;
    FOnValidateServerCertificate: TValidateCertificateEvent;
    FOnRequestCompleted: TRequestCompletedEvent;
    FOnRequestError: TRequestErrorEvent;
    FOnReceiveData: TReceiveDataEvent;
    FCustomHeaders: TNetHeaders;

    procedure DoOnRequestCompleted(const Sender: TObject;
      const AResponse: IHTTPResponse);
    procedure DoOnRequestError(const Sender: TObject; const AError: string);
    procedure DoOnReceiveData(const Sender: TObject; AContentLength: Int64;
      AReadCount: Int64; var Abort: Boolean);

    function GetMethodString: string;
    procedure SetMethodString(const Value: string);

    function GetURL: string;
    procedure SetURL(const Value: string);

    function GetClient: TMuHTTPClient;
    procedure SetClient(const Value: TMuHTTPClient);
    procedure SetOnNeedClientCertificate(const Value
      : TNeedClientCertificateEvent);
    procedure SetOnValidateServerCertificate(const Value
      : TValidateCertificateEvent);
    function GetOnReceiveData: TReceiveDataEvent;
    procedure SetOnReceiveData(const Value: TReceiveDataEvent);

    function GetRequest(const AMethod: string; const AURL: string;
      const ASourceStream: TStream): IHTTPRequest;
    function GetAccept: string;
    function GetAcceptCharSet: string;
    function GetAcceptEncoding: string;
    function GetAcceptLanguage: string;
    procedure SetAccept(const Value: string);
    procedure SetAcceptCharSet(const Value: string);
    procedure SetAcceptEncoding(const Value: string);
    procedure SetAcceptLanguage(const Value: string);
    function GetCustomHeaderValue(const AName: string): string;
    procedure SetCustomHeaderValue(const AName, Value: string);

  protected
    /// <summary> Notification method to process component adding or removal from a form/datamodule</summary>
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;

    /// <summary>You have to use this function to Execute the internal Request</summary>
    function DoExecute(const ARequest: IHTTPRequest;
      const AResponseContent: TStream; const AHeaders: TNetHeaders)
      : IHTTPResponse;

  public
    constructor Create(AOwner: TComponent); override;

    // ------------------------------------------- //
    // Standard HTTP Methods
    // ------------------------------------------- //
    /// <summary>Send 'DELETE' command to url</summary>
    function Delete(const AURL: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'OPTIONS' command to url</summary>
    function Options(const AURL: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'GET' command to url</summary>
    function Get(const AURL: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'TRACE' command to url</summary>
    function Trace(const AURL: string; const AResponseContent: TStream = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary>Send 'HEAD' command to url</summary>
    function Head(const AURL: string; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse;

    /// <summary>Send 'GET' command to url adding Range header</summary>
    /// <remarks>It's used for resume downloads</remarks>
    function GetRange(const AURL: string; AStart: Int64; AnEnd: Int64 = -1;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse;

    /// <summary>Post a raw file without multipart info</summary>
    function Post(const AURL: string; const ASourceFile: string;
      AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse; overload;
    /// <summary>Post TStrings values adding multipart info</summary>
    function Post(const AURL: string; const ASource: TStrings;
      const AResponseContent: TStream = nil; const AEncoding: TEncoding = nil;
      const AHeaders: TNetHeaders = nil): IHTTPResponse; overload;
    /// <summary>Post a stream without multipart info</summary>
    function Post(const AURL: string; const ASource: TStream;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse; overload;
    /// <summary>Post a multipart form data object</summary>
    function Post(const AURL: string; const ASource: TMultipartFormData;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse; overload;

    /// <summary>Send 'PUT' command to url</summary>
    function Put(const AURL: string; const ASource: TStream = nil;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse;

    // Non standard command procedures ...
    /// <summary>Send 'MERGE' command to url</summary>
    function Merge(const AURL: string; const ASource: TStream;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'MERGE' command to url</summary>
    function MergeAlternative(const AURL: string; const ASource: TStream;
      const AHeaders: TNetHeaders = nil): IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function Patch(const AURL: string; const ASource: TStream = nil;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse;
    /// <summary>Send 'PATCH' command to url</summary>
    function PatchAlternative(const AURL: string; const ASource: TStream = nil;
      const AResponseContent: TStream = nil; const AHeaders: TNetHeaders = nil)
      : IHTTPResponse;

    /// <summary>You have to use this function to Execute the internal Request</summary>
    function Execute(const AHeaders: TNetHeaders = nil): IHTTPResponse;

    /// <summary> CustomHeaders to be used by the client.</summary>
    property CustomHeaders[const AName: string]: string
      read GetCustomHeaderValue write SetCustomHeaderValue;
    /// <summary> Content stream associated with the request component</summary>
    property ContentStream: TStream read FContentStream write FContentStream;
    /// <summary> Source stream associated with the request component</summary>
    property SourceStream: TStream read FSourceStream write FSourceStream;

  published
    /// <summary>Property to manage the 'Accept' header</summary>
    property Accept: string read GetAccept write SetAccept;
    /// <summary>Property to manage the 'Accept-CharSet' header</summary>
    property AcceptCharSet: string read GetAcceptCharSet write SetAcceptCharSet;
    /// <summary>Property to manage the 'Accept-Encoding' header</summary>
    property AcceptEncoding: string read GetAcceptEncoding
      write SetAcceptEncoding;
    /// <summary>Property to manage the 'Accept-Language' header</summary>
    property AcceptLanguage: string read GetAcceptLanguage
      write SetAcceptLanguage;

    /// <summary> Property to access the MethodString from the request</summary>
    property MethodString: string read GetMethodString write SetMethodString;
    /// <summary> URL to be accessed</summary>
    property URL: string read GetURL write SetURL;
    /// <summary> Client component associated with the request component</summary>
    property Client: TMuHTTPClient read GetClient write SetClient;

    /// <summary> Event fired when a ClientCertificate is needed</summary>
    property OnNeedClientCertificate: TNeedClientCertificateEvent
      read FOnNeedClientCertificate write SetOnNeedClientCertificate;
    /// <summary> Event fired when checking the validity of a Server Certificate</summary>
    property OnValidateServerCertificate: TValidateCertificateEvent
      read FOnValidateServerCertificate write SetOnValidateServerCertificate;

    /// <summary> Event fired when a request finishes</summary>
    property OnRequestCompleted: TRequestCompletedEvent read FOnRequestCompleted
      write FOnRequestCompleted;
    /// <summary> Event fired when a request has an error</summary>
    property OnRequestError: TRequestErrorEvent read FOnRequestError
      write FOnRequestError;

    /// <summary>Property to manage the ReceiveData Event</summary>
    property OnReceiveData: TReceiveDataEvent read GetOnReceiveData
      write SetOnReceiveData;
  end;
  // ------------------------------------------------------------------------------------------------------------------ //
  // ------------------------------------------------------------------------------------------------------------------ //

implementation

uses
  System.NetConsts;

{ TMuHTTPClient }

constructor TMuHTTPClient.Create(AOwner: TComponent);
begin
  inherited;
  FHttpClient := THttpClient.Create;
  FHttpClient.OnReceiveData := DoOnReceiveData;
end;

function TMuHTTPClient.Delete(const AURL: string;
  const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.Delete(AURL, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

destructor TMuHTTPClient.Destroy;
begin
  FHttpClient.Free;
  inherited;
end;

procedure TMuHTTPClient.DoOnReceiveData(const Sender: TObject;
  AContentLength, AReadCount: Int64; var Abort: Boolean);
var
  LAbort: Boolean;
begin
  if assigned(FOnReceiveData) then
  begin
    LAbort := Abort;
    TThread.Synchronize(nil,
      procedure
      begin
        FOnReceiveData(Sender, AContentLength, AReadCount, LAbort);
      end);
    Abort := LAbort;
  end;
end;

procedure TMuHTTPClient.DoOnRequestCompleted(const Sender: TObject;
const AResponse: IHTTPResponse);
begin
  if assigned(FOnRequestCompleted) then
    TThread.Synchronize(nil,
      procedure
      begin
        FOnRequestCompleted(Sender, AResponse);
      end);
end;

procedure TMuHTTPClient.DoOnRequestError(const Sender: TObject;
const AError: string);
begin
  if assigned(FOnRequestError) then
    TThread.Synchronize(nil,
      procedure
      begin
        FOnRequestError(Sender, AError);
      end)
  else
    raise ENetHTTPClientException.Create(AError);
end;

function TMuHTTPClient.Execute(const ARequestMethod: string; const AURI: TURI;
const ASourceStream, AContentStream: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  try
    Result := IHTTPResponse(FHttpClient.Execute(ARequestMethod, AURI,
      ASourceStream, AContentStream, AHeaders));
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Execute(const ARequestMethod, AURIStr: string;
const ASourceStream, AContentStream: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  Result := Execute(ARequestMethod, TURI.Create(AURIStr), ASourceStream,
    AContentStream, AHeaders);
end;

function TMuHTTPClient.Execute(const ARequest: IHTTPRequest;
const AContentStream: TStream): IHTTPResponse;
begin
  try
    Result := FHttpClient.Execute(ARequest, AContentStream);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Get(const AURL: string; const AResponseContent: TStream;
const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.Get(AURL, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.GetAccept: string;
begin
  Result := FHttpClient.Accept;
end;

function TMuHTTPClient.GetAcceptCharSet: string;
begin
  Result := FHttpClient.AcceptCharSet;
end;

function TMuHTTPClient.GetAcceptEncoding: string;
begin
  Result := FHttpClient.AcceptEncoding;
end;

function TMuHTTPClient.GetAcceptLanguage: string;
begin
  Result := FHttpClient.AcceptLanguage;
end;

function TMuHTTPClient.GetAllowCookies: Boolean;
begin
  Result := FHttpClient.AllowCookies;
end;

function TMuHTTPClient.GetAuthEvent: TCredentialsStorage.TCredentialAuthevent;
begin
  Result := FHttpClient.AuthEvent;
end;

function TMuHTTPClient.GetContentType: string;
begin
  Result := FHttpClient.ContentType;
end;

function TMuHTTPClient.GetCookieManager: TCookieManager;
begin
  Result := FHttpClient.CookieManager;
end;

function TMuHTTPClient.GetCustomHeaderValue(const AName: string): string;
begin
  Result := FHttpClient.CustomHeaders[AName];
end;

function TMuHTTPClient.GetDirectTimes: Integer;
begin
  result:=FhttpClient.DirectTimes;
end;

function TMuHTTPClient.GetHandleRedirects: Boolean;
begin
  Result := FHttpClient.HandleRedirects;
end;

function TMuHTTPClient.GetLastURL: String;
begin
  Result := FHttpClient.URL;
end;

function TMuHTTPClient.GetCredentialsStorage: TCredentialsStorage;
begin
  Result := FHttpClient.CredentialsStorage;
end;

function TMuHTTPClient.GetMaxRedirects: Integer;
begin
  Result := FHttpClient.MaxRedirects;
end;

function TMuHTTPClient.GetOnNeedClientCertificate: TNeedClientCertificateEvent;
begin
  Result := FHttpClient.OnNeedClientCertificate;
end;

function TMuHTTPClient.GetOnValidateServerCertificate
  : TValidateCertificateEvent;
begin
  Result := FHttpClient.OnValidateServerCertificate;
end;

function TMuHTTPClient.GetProxySettings: TProxySettings;
begin
  Result := FHttpClient.ProxySettings;
end;

function TMuHTTPClient.GetRange(const AURL: string; AStart, AnEnd: Int64;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.GetRange(AURL, AStart, AnEnd, AResponseContent,
      AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.getReferer: String;
begin
  Result := FHttpClient.Referer;
end;

function TMuHTTPClient.GetUserAgent: string;
begin
  Result := FHttpClient.UserAgent;
end;

function TMuHTTPClient.Head(const AURL: string; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  try
    Result := FHttpClient.Head(AURL, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Merge(const AURL: string; const ASource: TStream;
const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.Merge(AURL, ASource, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.MergeAlternative(const AURL: string;
const ASource: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.MergeAlternative(AURL, ASource, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Options(const AURL: string;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.Options(AURL, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Patch(const AURL: string;
const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  try
    Result := FHttpClient.Patch(AURL, ASource, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.PatchAlternative(const AURL: string;
const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  try
    Result := FHttpClient.PatchAlternative(AURL, ASource, AResponseContent,
      AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Post(const AURL: string; const ASource: TStrings;
const AResponseContent: TStream; const AEncoding: TEncoding;
const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.Post(AURL, ASource, AResponseContent, AEncoding,
      AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Post(const AURL: string;
const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  try
    Result := FHttpClient.Post(AURL, ASource, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Post(const AURL: string;
const ASource: TMultipartFormData; const AResponseContent: TStream;
const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.Post(AURL, ASource, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Post(const AURL, ASourceFile: string;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.Post(AURL, ASourceFile, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPClient.Put(const AURL: string;
const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  try
    Result := FHttpClient.Put(AURL, ASource, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

procedure TMuHTTPClient.SetAccept(const Value: string);
begin
  FHttpClient.Accept := Value;
end;

procedure TMuHTTPClient.SetAcceptCharSet(const Value: string);
begin
  FHttpClient.AcceptCharSet := Value;
end;

procedure TMuHTTPClient.SetAcceptEncoding(const Value: string);
begin
  FHttpClient.AcceptEncoding := Value;
end;

procedure TMuHTTPClient.SetAcceptLanguage(const Value: string);
begin
  FHttpClient.AcceptLanguage := Value;
end;

procedure TMuHTTPClient.SetAllowCookies(const Value: Boolean);
begin
  FHttpClient.AllowCookies := Value;
end;

procedure TMuHTTPClient.SetAuthEvent(const Value
  : TCredentialsStorage.TCredentialAuthevent);
begin
  FHttpClient.AuthEvent := Value;
end;

procedure TMuHTTPClient.SetContentType(const Value: string);
begin
  FHttpClient.ContentType := Value;
end;

procedure TMuHTTPClient.SetCookieManager(const Value: TCookieManager);
begin
  FHttpClient.CookieManager := Value;
end;

procedure TMuHTTPClient.SetCredentialsStorage(const Value: TCredentialsStorage);
begin
  FHttpClient.CredentialsStorage := Value;
end;

procedure TMuHTTPClient.SetCustomHeaderValue(const AName, Value: string);
begin
  FHttpClient.CustomHeaders[AName] := Value;
end;

procedure TMuHTTPClient.SetHandleRedirects(const Value: Boolean);
begin
  FHttpClient.HandleRedirects := Value;
end;

procedure TMuHTTPClient.SetMaxRedirects(const Value: Integer);
begin
  FHttpClient.MaxRedirects := Value;
end;

procedure TMuHTTPClient.SetOnNeedClientCertificate
  (const Value: TNeedClientCertificateEvent);
begin
  FHttpClient.OnNeedClientCertificate := Value;
end;

procedure TMuHTTPClient.SetOnValidateServerCertificate
  (const Value: TValidateCertificateEvent);
begin
  FHttpClient.OnValidateServerCertificate := Value;
end;

procedure TMuHTTPClient.SetProxySettings(const Value: TProxySettings);
begin
  FHttpClient.ProxySettings := Value;
end;

procedure TMuHTTPClient.setReferer(aValue: string);
begin
  FHttpClient.Referer := aValue;
end;

procedure TMuHTTPClient.SetUserAgent(const Value: string);
begin
  FHttpClient.UserAgent := Value;
end;

function TMuHTTPClient.Trace(const AURL: string;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  try
    Result := FHttpClient.Trace(AURL, AResponseContent, AHeaders);
    DoOnRequestCompleted(self, Result);
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //
// ------------------------------------------------------------------------------------------------------------------ //

{ TMuHTTPRequest }

constructor TMuHTTPRequest.Create(AOwner: TComponent);
begin
  inherited;
end;

procedure TMuHTTPRequest.DoOnReceiveData(const Sender: TObject;
AContentLength, AReadCount: Int64; var Abort: Boolean);
var
  LAbort: Boolean;
begin
  if assigned(FOnReceiveData) then
  begin
    LAbort := Abort;
    TThread.Synchronize(nil,
      procedure
      begin
        FOnReceiveData(Sender, AContentLength, AReadCount, LAbort);
      end);
    Abort := LAbort;
  end
  else
    FClient.DoOnReceiveData(self, AContentLength, AReadCount, Abort);
end;

procedure TMuHTTPRequest.DoOnRequestCompleted(const Sender: TObject;
const AResponse: IHTTPResponse);
begin
  if assigned(FOnRequestCompleted) then
    TThread.Synchronize(nil,
      procedure
      begin
        FOnRequestCompleted(Sender, AResponse);
      end)
  else
    FClient.DoOnRequestCompleted(self, AResponse);
end;

procedure TMuHTTPRequest.DoOnRequestError(const Sender: TObject;
const AError: string);
begin
  if assigned(FOnRequestError) then
    TThread.Synchronize(nil,
      procedure
      begin
        FOnRequestError(Sender, AError);
      end)
  else
    FClient.DoOnRequestError(self, AError);
end;

function TMuHTTPRequest.Delete(const AURL: string;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodDelete, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TMuHTTPRequest.Execute(const AHeaders: TNetHeaders = nil)
  : IHTTPResponse;
begin
  FHttpRequest := GetRequest(FMethodString, FURL, nil);
  Result := DoExecute(FHttpRequest, FContentStream, AHeaders);
end;

function TMuHTTPRequest.DoExecute(const ARequest: IHTTPRequest;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  Result := nil;
  FHttpResponse := nil;
  if ARequest <> nil then
  begin
    try
      LHeaders := FCustomHeaders + AHeaders;
      Result := FClient.FHttpClient.Execute(ARequest, AResponseContent,
        LHeaders);
      FHttpResponse := Result;
      DoOnRequestCompleted(self, Result);
    except
      on E: Exception do
        DoOnRequestError(self, E.Message);
    end;
  end;
end;

function TMuHTTPRequest.Get(const AURL: string; const AResponseContent: TStream;
const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodGet, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TMuHTTPRequest.GetAccept: string;
begin
  Result := CustomHeaders[sAccept];
end;

function TMuHTTPRequest.GetAcceptCharSet: string;
begin
  Result := CustomHeaders[sAcceptCharSet];
end;

function TMuHTTPRequest.GetAcceptEncoding: string;
begin
  Result := CustomHeaders[sAcceptEncoding];
end;

function TMuHTTPRequest.GetAcceptLanguage: string;
begin
  Result := CustomHeaders[sAcceptLanguage];
end;

function TMuHTTPRequest.GetClient: TMuHTTPClient;
begin
  Result := FClient;
end;

function TMuHTTPRequest.GetCustomHeaderValue(const AName: string): string;
var
  I, Max: Integer;
begin
  Result := '';
  I := 0;
  Max := Length(FCustomHeaders);
  while I < Max do
  begin
    if string.CompareText(FCustomHeaders[I].Name, AName) = 0 then
    begin
      Result := FCustomHeaders[I].Value;
      break;
    end;
    Inc(I);
  end;
end;

function TMuHTTPRequest.GetMethodString: string;
begin
  Result := FMethodString;
end;

function TMuHTTPRequest.GetOnReceiveData: TReceiveDataEvent;
begin
  Result := FOnReceiveData;
end;

function TMuHTTPRequest.GetRange(const AURL: string; AStart, AnEnd: Int64;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
  LRange: string;
begin
  LRange := 'bytes=';
  if AStart > -1 then
    LRange := LRange + AStart.ToString;
  LRange := LRange + '-';
  if AnEnd > -1 then
    LRange := LRange + AnEnd.ToString;
  LHeaders := AHeaders + [TNetHeader.Create('Range', LRange)];
  // do not translate
  Result := Get(AURL, AResponseContent, LHeaders);
end;

function TMuHTTPRequest.GetRequest(const AMethod, AURL: string;
const ASourceStream: TStream): IHTTPRequest;
begin
  if FClient = nil then
    raise ENetHTTPRequestException.CreateRes(@SNetHttpComponentRequestClient);
  try
    Result := nil;
    Result := FClient.FHttpClient.GetRequest(AMethod, AURL);
    Result.OnReceiveData := DoOnReceiveData;
    if ASourceStream = nil then
      Result.SourceStream := FSourceStream
    else
      Result.SourceStream := ASourceStream;
  except
    on E: Exception do
      DoOnRequestError(self, E.Message);
  end;
end;

function TMuHTTPRequest.GetURL: string;
begin
  Result := FURL;
end;

function TMuHTTPRequest.Head(const AURL: string; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodHead, AURL, nil);
  Result := DoExecute(FHttpRequest, nil, AHeaders);
end;

function TMuHTTPRequest.Merge(const AURL: string; const ASource: TStream;
const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodMerge, AURL, ASource);
  Result := DoExecute(FHttpRequest, nil, AHeaders);
end;

function TMuHTTPRequest.MergeAlternative(const AURL: string;
const ASource: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  LHeaders := [TNetHeader.Create(sXMethodOverride, sHTTPMethodPatch),
    TNetHeader.Create('PATCHTYPE', sHTTPMethodMerge)] + AHeaders;
  // Do not translate
  Result := DoExecute(FHttpRequest, nil, LHeaders);
end;

procedure TMuHTTPRequest.Notification(AComponent: TComponent;
Operation: TOperation);
begin
  inherited;
  if (AComponent = FClient) and (Operation = opRemove) then
    SetClient(nil);
end;

function TMuHTTPRequest.Options(const AURL: string;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodOptions, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TMuHTTPRequest.Patch(const AURL: string;
const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPatch, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TMuHTTPRequest.PatchAlternative(const AURL: string;
const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
var
  LHeaders: TNetHeaders;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  LHeaders := [TNetHeader.Create(sXMethodOverride, sHTTPMethodPatch)] +
    AHeaders;
  Result := DoExecute(FHttpRequest, AResponseContent, LHeaders);
end;

function TMuHTTPRequest.Post(const AURL: string; const ASource: TStrings;
const AResponseContent: TStream; const AEncoding: TEncoding;
const AHeaders: TNetHeaders): IHTTPResponse;
var
  LSourceStream: TStringStream;
  OldLineBreak: string;
  LParams: string;
  LHeaders: TNetHeaders;
  LEncodingName: string;
  LEncoding: TEncoding;
begin
  OldLineBreak := ASource.LineBreak;
  ASource.LineBreak := '&';
  try
    LParams := ASource.Text;
    if LParams <> '' then
      SetLength(LParams, LParams.Length - 1); // Remove last '&'
  finally
    ASource.LineBreak := OldLineBreak;
  end;
  if AEncoding = nil then
  begin
    LEncoding := TEncoding.UTF8;
    LEncodingName := 'UTF-8';
  end
  else
  begin
    LEncoding := AEncoding;
    LEncodingName := AEncoding.EncodingName;
  end;
  LEncodingName := THttpClient.EncodingNameToHttpEncodingName
    (LEncoding.EncodingName);
  LSourceStream := TStringStream.Create(LParams, LEncoding, false);
  try
    FHttpRequest := GetRequest(sHTTPMethodPost, AURL, LSourceStream);
    LHeaders := [TNetHeader.Create(sContentType,
      'application/x-www-form-urlencoded; charset=' + LEncodingName)] +
      AHeaders; // do not translate
    Result := DoExecute(FHttpRequest, AResponseContent, LHeaders);
  finally
    LSourceStream.Free;
  end;
end;

function TMuHTTPRequest.Post(const AURL: string;
const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPost, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TMuHTTPRequest.Post(const AURL: string;
const ASource: TMultipartFormData; const AResponseContent: TStream;
const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPost, AURL, ASource.Stream);
  if FHttpRequest <> nil then
  begin
    FHttpRequest.SourceStream.Position := 0;
    FHttpRequest.AddHeader(sContentType, ASource.MimeTypeHeader);
  end;
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

function TMuHTTPRequest.Post(const AURL, ASourceFile: string;
AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
var
  LSourceStream: TStream;
begin
  LSourceStream := TFileStream.Create(ASourceFile, fmOpenRead);
  try
    Result := Post(AURL, LSourceStream, AResponseContent, AHeaders);
  finally
    LSourceStream.Free;
  end;
end;

function TMuHTTPRequest.Put(const AURL: string;
const ASource, AResponseContent: TStream; const AHeaders: TNetHeaders)
  : IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodPut, AURL, ASource);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

procedure TMuHTTPRequest.SetAccept(const Value: string);
begin
  CustomHeaders[sAccept] := Value
end;

procedure TMuHTTPRequest.SetAcceptCharSet(const Value: string);
begin
  CustomHeaders[sAcceptCharSet] := Value
end;

procedure TMuHTTPRequest.SetAcceptEncoding(const Value: string);
begin
  CustomHeaders[sAcceptEncoding] := Value
end;

procedure TMuHTTPRequest.SetAcceptLanguage(const Value: string);
begin
  CustomHeaders[sAcceptLanguage] := Value
end;

procedure TMuHTTPRequest.SetClient(const Value: TMuHTTPClient);
begin
  FClient := Value;
end;

procedure TMuHTTPRequest.SetCustomHeaderValue(const AName, Value: string);
var
  I, Max: Integer;
begin
  I := 0;
  Max := Length(FCustomHeaders);
  while I < Max do
  begin
    if string.CompareText(FCustomHeaders[I].Name, AName) = 0 then
      break;
    Inc(I);
  end;
  if I = Max then
  begin
    SetLength(FCustomHeaders, Max + 1);
    FCustomHeaders[I].Name := AName;
  end;
  FCustomHeaders[I].Value := Value;
end;

procedure TMuHTTPRequest.SetMethodString(const Value: string);
begin
  FMethodString := Value;
end;

procedure TMuHTTPRequest.SetOnNeedClientCertificate
  (const Value: TNeedClientCertificateEvent);
begin
  FOnNeedClientCertificate := Value;
end;

procedure TMuHTTPRequest.SetOnReceiveData(const Value: TReceiveDataEvent);
begin
  FOnReceiveData := Value;
end;

procedure TMuHTTPRequest.SetOnValidateServerCertificate
  (const Value: TValidateCertificateEvent);
begin
  FOnValidateServerCertificate := Value;
end;

procedure TMuHTTPRequest.SetURL(const Value: string);
begin
  FURL := Value;
end;

function TMuHTTPRequest.Trace(const AURL: string;
const AResponseContent: TStream; const AHeaders: TNetHeaders): IHTTPResponse;
begin
  FHttpRequest := GetRequest(sHTTPMethodTrace, AURL, nil);
  Result := DoExecute(FHttpRequest, AResponseContent, AHeaders);
end;

end.
